#!/usr/bin/env python3

import curses
import csv
import os

class Router:
    def __init__(self, type, name, ip):
        self.type = type
        self.name = name
        self.ip = ip

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.name)

    def __str__(self):
        return f"{self.ip} - {self.name}"

def parse_csv_to_routers(file_path):
    p_leaf_routers = []
    x_leaf_routers = []
    emux_routers = []

    with open(file_path, mode='r') as file:
        csv_reader = csv.reader(file)
        for row in csv_reader:
            type, name, ip = row
            router = Router(type, name, ip)
            if type == 'P-LEAF':
                p_leaf_routers.append(router)
            elif type == 'X-LEAF':
                x_leaf_routers.append(router)
            elif type == 'EMUX':
                emux_routers.append(router)
            else:
                print(f"Unknown router type: {type}")

    return p_leaf_routers, x_leaf_routers, emux_routers

class Fault:
    def __init__(self, event, group, n_args, args):
        self.event = event
        self.group = group
        self.n_args = n_args
        self.args = args

    def __repr__(self):
        return f"Fault(event='{self.event}', group='{self.group}', n_args={self.n_args}, args={self.args})"

    def __str__(self):
        return self.event

    def __len__(self):
        return len(self.event)

class Action:
    def __init__(self, fault: Fault, routers: list[Router]):
        self.fault = fault
        self.routers = routers

    def to_csv(self):
        csv = ""

        for router in self.routers:
            csv += f"{router.ip},"
            csv += f"{self.fault.event} "
            for i, arg in enumerate(self.fault.args):
                csv += f"arg{i + 1} {arg} "
            csv += "\n"

        return csv

    @staticmethod
    def from_csv(filepath):
        with open(filepath, mode='r') as file:
            csv_reader = csv.reader(file)
            routers = []
            for row in csv_reader:
                ip, action = row
                routers.append(Router(ip, action))
        return routers


def read_csv_to_faults(filename):
    faults = []
    with open(filename, mode='r') as file:
        csv_reader = csv.reader(file)
        headers = next(csv_reader)  # Skip the header row
        for row in csv_reader:
            event = row[0]
            group = row[1]
            n_args = int(row[2])
            args = row[3:3 + n_args]
            fault = Fault(event, group, n_args, args)
            faults.append(fault)
    return faults


def get_fault_groups(faults):
    return list(set(fault.group for fault in faults))

def get_faults_by_group(faults, group):
    return [str(fault) for fault in faults if fault.group == group]

def get_fault_by_event(faults, event):
    return [fault for fault in faults if fault.event == event]


def display_menu_checkboxes(stdscr, question, options):
    curses.curs_set(0)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
    selected_indices = set()
    current_index = 0
    max_option_length = max(len(option) for option in options) + 4
    starting_y = 6

    while True:
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        stdscr.addstr(1, width // 2 - len(question) // 2, question)

        for idx, option in enumerate(options):
            option = str(option)
            x = width // 2 - max_option_length // 2
            y = starting_y - len(options) // 2 + idx + 2
            if idx == current_index:
                stdscr.attron(curses.color_pair(1))
            if idx in selected_indices:
                stdscr.addstr(y, x, "[x] " + option)
            else:
                stdscr.addstr(y, x, "[ ] " + option)
            if idx == current_index:
                stdscr.attroff(curses.color_pair(1))

        stdscr.refresh()

        key = stdscr.getch()

        if key == curses.KEY_UP and current_index > 0:
            current_index -= 1
        elif key == curses.KEY_DOWN and current_index < len(options) - 1:
            current_index += 1
        elif key == ord(' '):
            if current_index in selected_indices:
                selected_indices.remove(current_index)
            else:
                selected_indices.add(current_index)
        elif key == ord('\n'):
            break

    return [options[i] for i in selected_indices]

def display_menu_radio(stdscr, question, options):
    curses.curs_set(0)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
    selected_index = None
    current_index = 0
    max_option_length = max(len(option) for option in options) + 4

    starting_y = 6
    starting_x = 2

    while True:
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        stdscr.addstr(1, width // 2 - len(question) // 2, question)

        for idx, option in enumerate(options):
            option = str(option)
            x = width // 2 - max_option_length // 2
            y = starting_y - len(options) // 2 + idx + 2
            if idx == current_index:
                stdscr.attron(curses.color_pair(1))
            if idx == selected_index:
                stdscr.addstr(y, x, "(x) " + option)
            else:
                stdscr.addstr(y, x, "( ) " + option)
            if idx == current_index:
                stdscr.attroff(curses.color_pair(1))

        stdscr.refresh()

        key = stdscr.getch()

        if key == curses.KEY_UP and current_index > 0:
            current_index -= 1
        elif key == curses.KEY_DOWN and current_index < len(options) - 1:
            current_index += 1
        elif key == ord(' '):
            selected_index = current_index
        elif key == ord('\n') and selected_index is not None:
            break

    return options[selected_index] if selected_index is not None else None

def get_user_input(stdscr, prompt):
    curses.echo()
    stdscr.addstr(prompt)
    stdscr.refresh()
    user_input = stdscr.getstr().decode('utf-8')
    curses.noecho()
    return user_input


faults = ['CPU', 'Memory', 'Link', 'Power', 'Fan']

SAVED_SCENARIO_PATH = "./test_scenarios"
OUTPUT_LOGS_PATH = "./logs"
FAULTS_CSV_PATH = "./faults.csv"
ROUTERS_CSV_PATH = "./routers.csv"

fault_list = read_csv_to_faults(FAULTS_CSV_PATH)
fault_groups = get_fault_groups(fault_list)

p_leaf_routers, x_leaf_routers, emux_routers = parse_csv_to_routers(ROUTERS_CSV_PATH)


def display_arg_setter(stdscr, fault_name, num_args):
    curses.curs_set(1)
    stdscr.clear()

    args = ["" for _ in range(num_args)]

    current_arg = 0
    error_message = ""

    while True:
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # Print the header
        header = "The arguments for the fault"
        stdscr.addstr(0, (width - len(header)) // 2, header)

        # Print the fault name
        fault_header = f"Fault: {fault_name}"
        stdscr.addstr(1, (width - len(fault_header)) // 2, fault_header)

        start_y = 3  # Adjusted to reduce the space
        start_x = 2  # Center the arguments list

        for idx in range(num_args):
            x = start_x
            y = start_y + idx
            stdscr.addstr(y, x, f"arg{idx + 1}:")

            arg_pos = x + len(f"arg{idx + 1}:") + 1
            if arg_pos < width - 8:  # Ensure we do not go beyond the window width
                if idx == current_arg:
                    stdscr.attron(curses.A_REVERSE)
                stdscr.addstr(y, arg_pos, f"{args[idx]:<10}")
                stdscr.attroff(curses.A_REVERSE)

        stdscr.addstr(start_y + num_args + 1, start_x, "Press Enter to submit, or use up/down keys to navigate.")

        if error_message:
            stdscr.addstr(start_y + num_args + 2, start_x, error_message, curses.color_pair(1))

        key = stdscr.getch()

        if key == curses.KEY_DOWN:
            current_arg = (current_arg + 1) % num_args
        elif key == curses.KEY_UP:
            current_arg = (current_arg - 1) % num_args
        elif key == curses.KEY_ENTER or key in [10, 13]:
            if all(args):
                break
            else:
                error_message = "Please fill out all the argument fields"
                curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
        elif key == curses.KEY_BACKSPACE or key == 127:  # Handle Backspace key
            if args[current_arg]:
                args[current_arg] = args[current_arg][:-1]
        elif 32 <= key <= 126:  # Printable ASCII range
            if len(args[current_arg]) < 10:
                args[current_arg] = args[current_arg] + chr(key)

        stdscr.refresh()

    stdscr.clear()

    return args

def display_creator(stdscr):
    question1 = "Select a set of P-Leaf routers by pressing space to use and press ENTER:"
    selected_p_leaf_routers = display_menu_checkboxes(stdscr, question1, p_leaf_routers)

    question2 = "Select a set of X-Leaf routers to use and press ENTER:"
    selected_x_leaf_routers = display_menu_checkboxes(stdscr, question2, x_leaf_routers)

    question3 = "Select a set of EMUX routers to use and press ENTER:"
    selected_emux_routers = display_menu_checkboxes(stdscr, question3, emux_routers)

    question4 = "Select a fault group and press ENTER:"
    selected_fault_group = display_menu_radio(stdscr, question4, fault_groups)

    specific_event_faults = get_faults_by_group(fault_list, selected_fault_group)
    select_fault = "Select a fault from {} and press ENTER:".format(selected_fault_group)
    selected_fault = display_menu_radio(stdscr, select_fault, specific_event_faults)

    selected_fault_object = get_fault_by_event(fault_list, selected_fault)[0]
    args = display_arg_setter(stdscr, selected_fault, selected_fault_object.n_args)

    selected_fault_object.args = args

    stdscr.clear()
    stdscr.addstr(1, 0, "You selected the following P-Leaf routers:")
    if len(selected_p_leaf_routers) == 0:
        stdscr.addstr(y_offset + 1, 0, "- No P-leaf routers selected")
    for i, item in enumerate(selected_p_leaf_routers):
        stdscr.addstr(2 + i, 0, f"- {item}")

    y_offset = 4 + len(selected_p_leaf_routers)
    stdscr.addstr(y_offset, 0, "You selected the following X-Leaf routers:")
    if len(selected_x_leaf_routers) == 0:
        stdscr.addstr(y_offset + 1, 0, "- No X-leaf routers selected")
    for i, item in enumerate(selected_x_leaf_routers):
        stdscr.addstr(y_offset + 1 + i, 0, f"- {item}")

    y_offset += 3 + len(selected_x_leaf_routers)
    stdscr.addstr(y_offset, 0, "You selected the following EMUX routers:")

    if len(selected_emux_routers) == 0:
        stdscr.addstr(y_offset + 1, 0, "- No EMUX routers selected")

    for i, item in enumerate(selected_emux_routers):
        stdscr.addstr(y_offset + 1 + i, 0, f"- {item}")

    y_offset += 3 + len(selected_emux_routers)
    stdscr.addstr(y_offset, 0, "You selected the following fault:")
    stdscr.addstr(y_offset + 1, 0, f"- {selected_fault}")

    for i, arg in enumerate(args):
        stdscr.addstr(y_offset + 2 + i, 0, f"- arg{i + 1}: {arg}")

    y_offset += 3 + len(args)
    stdscr.addstr(y_offset, 0, "Scenario will be saved to the following path: " + SAVED_SCENARIO_PATH)
    stdscr.addstr(y_offset + 2, 0, "Please enter the name of this file: ")
    file_name = get_user_input(stdscr, " ")

    # check if user inputted name, if create an error and ask again
    while file_name == "":
        stdscr.refresh()
        stdscr.addstr(y_offset + 3, 0, "Error! Please enter a valid nonempty name:  ")
        file_name = get_user_input(stdscr, " ")
        if file_name != "":
            break

    stdscr.refresh()
    action = Action(selected_fault_object, selected_p_leaf_routers + selected_x_leaf_routers + selected_emux_routers)
    csv = action.to_csv()
    # create a path with saved scenario path and filename
    path = os.path.join(SAVED_SCENARIO_PATH, file_name + ".csv")

    with open(path, mode='w') as file:
        file.write(csv)

    stdscr.clear()
    stdscr.addstr(0, 0, f"Success! File written to {SAVED_SCENARIO_PATH}. Press ENTER to conintue.")
    stdscr.refresh()
    stdscr.getch()

def display_scenarios(stdscr):
    # read from test_scenarios folder and get a list of filenames

    scenario_filenames = os.listdir(SAVED_SCENARIO_PATH)
    csv_len = len(".csv")
    scenario_names = [name[:-csv_len] for name in scenario_filenames]
    scenario_names.append("Back")

    question = "Select a scenario to execute and press ENTER:"
    selected_scenario = display_menu_radio(stdscr, question, scenario_names)

    if selected_scenario == "Back":
        return

    if selected_scenario is not None:
        file_path = os.path.join(SAVED_SCENARIO_PATH, selected_scenario + ".csv")
        routers = Action.from_csv(file_path)

        stdscr.clear()
        stdscr.addstr(0, 0, f"Executing scenario {selected_scenario}. Press ENTER to continue.")
        stdscr.refresh()


def main(stdscr):

    menuOptions = [
        "Create a test scenario",
        "Execute an existing test scenario",
        "Exit",
    ]

    while True:
        question1 = "Choose one of the following menu items and press ENTER:"
        selected_item_radio = display_menu_radio(stdscr, question1, menuOptions)

        if selected_item_radio == "Create a test scenario":
            display_creator(stdscr)
        elif selected_item_radio == "Execute an existing test scenario":
            display_scenarios(stdscr)
        elif selected_item_radio == "Exit":
            break


if __name__ == "__main__":
    curses.wrapper(main)
